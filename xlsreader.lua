----------------------------------------------------------------------------------- XLS Reader : A collection of utilities for reading XLS files.---------------------------------------------------------------------------------local modname = ... local M = {}_G[modname] = Mpackage.loaded[modname] = Msetmetatable(M, {__index = _G})setfenv(1, M)require "luacom"	-- Active X object handlerlocal gpg = require("gpgUtilities")local l_fields = nillocal l_maxCols = 50local l_maxRows = 1000local l_requireAllFieldsIndexed = truelocal l_endLoadingOnFirstBlankRowFound = true--------------------------------------------------------------------------------- SetShowDebugMessages--	Used to set the show debug message flag on the local instance of the--	gpg utilities object.--function SetShowDebugMessages(show)	gpg.SetShowDebugMessages(show)end	-- SetShowDebugMessages--------------------------------------------------------------------------------- AddFieldNames--	Adds XLS field names to our collection for search and processing----	Arguments:--		Can be one of three variations:--		1.	A single argument with a table containing the field names --		2.	A variable number of arguments, each containing a field name.--		3.	No arguments, the field names collection is cleared.--function AddFieldNames(...)	local args = {...}	local flags = {}	if (#args == 0) then ClearFieldNames() end	if (#args == 1 and type(args[1]) == "table") then args = args[1] end	if (#args > l_maxCols) then print("WARNING - there are more column names specified than the maximum number of columns to traverse - is this expected?") end		l_fields = {}		for _,k in pairs(args) do		l_fields[k] = 0	end	end	-- AddFieldNames--------------------------------------------------------------------------------- ClearFieldNames-- 	Clears our field name collection and sets the collection to nil.--function ClearFieldNames()	l_fields = nilend	-- ClearFieldNames--------------------------------------------------------------------------------- SetMaxRows--	Sets the maximum number of rows that will be traversed.--function SetMaxRows(n)	assert(type(n) == "number")	assert(n >= 0)		l_maxRows = nend	-- SetMaxRows--------------------------------------------------------------------------------- SetMaxColumns--	Sets the maximum number of columns that will be traversed.--function SetMaxColumns(n)	assert(type(n) == "number")	assert(n >= 0)		l_maxCols = nend	-- SetMaxColumns-------------------------------------------------------------------------------
-- SetRequireAllFieldsIndexed--	Sets a flag that indicates if all registered fields must be indexed before--	processing is allowed to continue.----	Arguments:--		q	: Boolean setting for this flag - calling with nil assumes q == true.--function SetRequireAllFieldsIndexed(q)	if (q == nil) then q = true end	assert(type(q) == "boolean", "The argument must be boolean.")	l_requireAllFieldsIndexed = q	end	-- SetRequireAllColumnsIndexed-------------------------------------------------------------------------------
-- SetEndLoadingOnFirstBlankRowFound--	Sets a flag that indicates loading of the worksheet will end on the first--	blank row found.----	Arguments:--		q	: Boolean setting for this flag - calling with nil assumes q == true.--function SetEndLoadingOnFirstBlankRowFound(q)	if (q == nil) then q = true end	assert(type(q) == "boolean", "The argument must be boolean.")	l_endLoadingOnFirstBlankRowFound = qend	-- SetEndLoadingOnFirstBlankRowFound--------------------------------------------------------------------------------- IndexXlsHeaderColumns--	Find the column index associated with each header name in the XLS sheet.--	The XLS sheet must have the column header loaded in the first row of the sheet.----	Arguments:--		sheet:  A worksheet object from an open XLS workbook object.--function IndexXlsHeaderColumns(sheet)	assert(l_fields ~= nil and type(l_fields) == "table", "The fields collection must be populated prior to calling this method.")	assert(sheet ~= nil and type(sheet) == "table", "The supplied sheet must be populated before calling this method.")		if (gpg.GetShowDebugMessages()) then print("Showing gpg.DEBUG messages") end		gpg.DebugMessage("Indexing target columns in XLS sheet ... ")	gpg.DebugMessage(l_requireAllFieldsIndexed and "Indexing of all fields is required." or "Indexing of all fields is NOT required.")	for k,v in pairs(l_fields) do		local dbgmsg = "Locating field - " .. k .. " - "		for i = 1, l_maxCols do			local cell = sheet.Cells(i)			if (cell == nil) then break end			if (cell.Value2 == nil) then dbgmsg = dbgmsg .. " not located" break end			if (gpg.TrimString(cell.Value2) == gpg.TrimString(k)) then				dbgmsg = dbgmsg .. " located at column " .. i				l_fields[k] = i				break			end		end		gpg.DebugMessage(dbgmsg)	end	if (gpg.GetShowDebugMessages()) then 		print("\nThe following XLS sheet columns were indexed : ")		for k,v in pairs(l_fields) do			print("\tField '" .. k .. "' is located at XLS column " .. gpg.SafeString(v))		end	endend	-- IndexXlsHeaderColumns-------------------------------------------------------------------------------
-- ValidateFieldsIndexed--	Tests that our fields collection has been initialized by:--	1.	All fields have non-zero indexes.--	2.	If all fields indexed is required, then no fields may have a zero index.--	3.	If all fiedls indexed is NOT required, at least one field has a non-zero index.----	Arguments:--			fields	:	The fields collection to be tested.--	Returns:--			true if fields have been indexed; false otherwise.--function ValidateFieldsIndexed(fields)	assert(fields ~= nil and type(fields) == "table", "The fields must be in a table.")	if (not(table.containsValue(fields, 0))) then return true end		-- [1]	if (l_requireAllFieldsIndexed) then return false end	-- [2]	for _,v in pairs(fields) do		if (v ~= 0) then return true end	-- [3]	end	return falseend	-- ValidateFieldsIndexed-------------------------------------------------------------------------------
-- ValidateRecordPopulation--	Returns a value indicating the row has been populated per requirements.--	If the l_endLoadingOnFirstBlankRowFound flag is set true and the record--	contains only blank fields, false is returned; otherwise true.--function ValidateRecordPopulation(record)	assert(record ~= nil and type(record) == "table", "The record must be a table.")	if (l_endLoadingOnFirstBlankRowFound == false) then return true end -- No need to test the record.	for _,v in pairs(record) do		if (not(gpg.StringIsNilOrEmpty(v))) then return true end	end	return falseend	-- ValidateRecordPopulation--------------------------------------------------------------------------------- LoadXlsRecords--	Loads XLS record from a provided XLS worksheet.--	Note:  The sheet columns must be indexed prior to reading the worksheet.----	Arguments:--		sheet:  A worksheet object from an open XLS workbook object.----	Returns:  A table loaded with records from the worksheet with each record a--						a table containing values from a single row keyed with column names.--function LoadXlsRecords(sheet)	assert(l_fields ~= nil and type(l_fields) == "table", "The fields collection before calling this method.")	assert(ValidateFieldsIndexed(l_fields), "The fields collection must " .. (l_requireAllFieldsIndexed and "be fully indexed" or "contain at least one index") .. " before calling this method.")	assert(sheet ~= nil and type(sheet) == "table", "The supplied sheet must be populated before calling this method.")	local buffer = {}	gpg.DebugMessage("Loading records from XLS sheet using indexed columns.")	local spinner = gpg.DisplayHack(8)	for row = 2, (2 + l_maxRows) - 1 do		if (not(gpg.GetShowDebugMessages())) then spinner() end	-- Do not show the spinner if we are in debug message mode.		local record = {}		gpg.DebugMessage("Reading row " .. row)		for fieldName, col in pairs(l_fields) do			if (col > 0) then 				local cell = sheet.Cells(row, col)				if (cell == nil) then break end				local val = gpg.SafeString(cell.Value2)				gpg.DebugMessage(fieldName .. "[" .. col .. "][" .. row .. "] = '" .. val .. "'")				record[fieldName] = tostring(val)			end		end		if (not(ValidateRecordPopulation(record))) then break end		table.insert(buffer, record)	end	return bufferend	-- LoadXlsRecords--------------------------------------------------------------------------------- ReadXlsFile--	Reads the data from a XLS workbook and worksheet.  This method handles creating--	an xls active X object, opening the workbook, and reading the requested data into--	a buffer.----	Arguments:--		workbookName - The FQN location of the XLS workbook to be processed.--		worksheetName - The name of the worksheet within workbookName to be processed.----	Returns:  A table loaded with records from the worksheet with each record a--						a table containing values from a single row keyed with column names.--function ReadXlsFile(workbookName, worksheetName)	assert(workbookName, "A workbook FQN name is required.")	assert(worksheetName, "A worksheet name is required.")	assert(l_fields ~= nil, "You must initialize the XLS reader fields collection before attempting to read the file.")	print("Creating the excel object .. ")	local excel = luacom.CreateObject("Excel.Application")	assert(excel)	excel.Visible = false	excel.DisplayAlerts = false	print("Loading the workbook .. ")	local book = excel.Workbooks:Open(workbookName)	assert(book)	io.write("Loading the work sheet ")	local sheet = book.Sheets(worksheetName)	assert(sheet)	IndexXlsHeaderColumns(sheet)	if (l_endLoadingOnFirstBlankRowFound) then io.write(" - Note: Loading of the worksheet will end on the first blank row found ") end	io.write(".. ")		local buffer = LoadXlsRecords(sheet)	print("\nClosing out worksheet, workbook and excel object .. ")	sheet = nil	book = nil	excel:Quit()	excel = nil	return bufferend	-- ReadXlsFile